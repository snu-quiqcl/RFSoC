#include <string.h>
#include "lwip/err.h"
#include "lwip/tcp.h"
#include "rfdc_controller.h"

#define COPY_DATA_ADDR 0x700010
#define TARGET_DATA_ADDR 0x700020

int64_t binary_mode = 0;
volatile unsigned char * current_addr = 0;
uint64_t current_addr_temp = 0;

__attribute__((always_inline)) static void memory_write(uint64_t addr, uint8_t data)
{
    volatile uint64_t * target_addr = (volatile uint64_t *) TARGET_DATA_ADDR;
    volatile uint8_t * copy_data_addr = (volatile uint8_t *) COPY_DATA_ADDR;

    *target_addr = addr;
    *copy_data_addr = data;

    __asm__ __volatile__(
		    "sub sp, sp, #24\n\t"
		    "str x0, [sp, #8]\n\t"
		    "str x1, [sp, #16]\n\t"
		    "ldr x0, [%0]\n\t"
		    "ldr x1, [%1]\n\t"
		    "str x1, [x0]\n\t"
		    "ldr x0, [sp, #8]\n\t"
		    "ldr x1, [sp, #16]\n\t"
		    "add sp, sp, #24\n\t"
		    ://Target
		    : "r" (TARGET_DATA_ADDR), "r" (COPY_DATA_ADDR)//Variable
		    ://Clover
		    );
}

int64_t simple_lexer(struct tcp_pcb *tpcb, const char * inst){
	int64_t module_num = 0;
	int64_t fnct_num = 0;
	int64_t param_num = 0;
	int64_t timestamp_num = 0;
	int64_t entry_point = 0;
	int64_t stack_start = 0;
	int64_t stack_end = 0;
	int64_t heap_start = 0;
	int64_t heap_end = 0;
	static int64_t packet_number = 0;
	static int64_t current_packet_num;
	module_num = get_module(inst);

	switch(module_num){
		case 0: // CPU
			fnct_num = get_fnct(inst);
			param_num = get_param(inst,3,4);
			run_cpu_process(tpcb,fnct_num,param_num);
			break;

		case 1: // Binary
			if(binary_mode == 0){
				fnct_num = get_fnct(inst);
				if( fnct_num == 3 ){
					xil_printf("SAVE DATA\r\n");
					entry_point = get_param(inst,3,4);
					stack_start = get_param(inst,4,5);
					stack_end = get_param(inst,5,6);
					heap_start = get_param(inst,6,7);
					heap_end = get_param(inst,7,8);
					packet_number = get_param(inst,8,9);
					run_bin_process(tpcb, fnct_num, entry_point, stack_start, stack_end, heap_start, heap_end, packet_number);
					binary_mode = 1;
					current_addr = (volatile unsigned char *)DRAM_BASE_ADDRESS;
					current_addr_temp = (uint64_t)DRAM_BASE_ADDRESS;
					current_packet_num = 0;
				}
				else if( fnct_num == 4 ){
					run_bin_process(tpcb, fnct_num, 0, 0, 0, 0, 0, 0);
				}
			}
			else if(binary_mode == 1){
				int64_t i = 0;
				while( is_end(inst,i+2,i+3)!= 1 ){
					//*(current_addr) = (volatile unsigned char)get_param(inst,i+2,i+3);
					//current_addr++;
					//i++;
					memory_write(current_addr_temp,(uint8_t)get_param(inst,i+2,i+3));
					current_addr_temp++;
					i++;
				}
				current_packet_num++;
				if( current_packet_num == packet_number){
					xil_printf("\r\nEND PACKET NUM : %d\r\n",current_packet_num);
					xil_printf("current_addr : %llx\r\n",current_addr);
					binary_mode = 0;
				}
			}
			break;

		default: // Module
			fnct_num = get_fnct(inst);
			timestamp_num = get_param(inst,3,4);
			param_num = get_param(inst,4,5);
			run_rtio_process(tpcb,module_num, fnct_num, timestamp_num, param_num);
			break;
	}

}

void clear_DRAM(){
	unsigned char * addr = DRAM_BASE_ADDRESS;
	do{
		*(addr) = 0;
		addr++;
	}while( addr != current_addr);
	xil_printf("DRAM CELANED\r\n");
}

void set_current_binary_mode(int64_t mode){
	binary_mode = mode;
	return;
}

INLINE int64_t get_module(const char * inst){
	int64_t i = 0;
	int64_t pos1 = 0;
	int64_t pos2 = 0;
	pos1 = string_count(inst,1,'#')+1;
	pos2 = string_count(inst,2,'#');
	char temp_str[1024] = {'\0'};
	substring(temp_str,inst,pos1,pos2);
	while(i < MODULE_NUM){
		if(strcmp(temp_str,MODULE[i].module_name) == 0){
			i = MODULE[i].num;
			return i;
		}
		i++;
	}
	return i;
}

INLINE int64_t get_fnct(const char * inst){
	int64_t i = 0;
	int64_t pos1 = 0;
	int64_t pos2 = 0;
	pos1 = string_count(inst,2,'#')+1;
	pos2 = string_count(inst,3,'#');
	char temp_str[1024] = {'\0'};
	substring(temp_str,inst,pos1,pos2);
	while(i < FNCT_NUM){
		if(strcmp(temp_str,FNCT[i].fnct_name) == 0){
			i = FNCT[i].num;
			return i;
		}
		i++;
	}
	return i;
}

INLINE int64_t get_param(const char *inst, int64_t start_index, int64_t end_index){
	int64_t pos1 = 0;
	int64_t pos2 = 0;
	int64_t num = 0;
	pos1 = string_count(inst,start_index,'#')+1;
	pos2 = string_count(inst,end_index,'#');
	char temp_str[1024] = {'\0'};
	substring(temp_str,inst,pos1,pos2);
	num = string2int64(temp_str);
	return num;
}

INLINE int64_t is_end(const char * inst, int64_t start_index, int64_t end_index){
	int64_t pos1 = 0;
	int64_t pos2 = 0;
	pos1 = string_count(inst,start_index,'#')+1;
	pos2 = string_count(inst,end_index,'#');
	char temp_str[1024] = {'\0'};
	substring(temp_str,inst,pos1,pos2);
	if( strcmp(temp_str,"!EOL") == 0 ){
		return 1;
	}
	else{
		return 0;
	}
}
